#include<bits/stdc++.h>
using namespace std;

struct Node{
    int data;
    Node *left, *right, *parent;
    Node(int x){
        data = x;
        left = right = parent = NULL;
    }
};

void inorder(vector<int>& parent, Node* root, Node* p, vector<int> &in_order_traversal){
    if(root == NULL){
        return;
    }
    inorder(parent, root->left, root, in_order_traversal);
    
    in_order_traversal.push_back(root->data);
    parent[root->data] = p->data;
    
    inorder(parent, root->right, root, in_order_traversal);
}

void postorder(Node* root){
    if(root == NULL){
        return;
    }
    postorder(root->left);
    postorder(root->right);
    cout << root->data << " ";
}
bool isPrime(int n) {
    if (n <= 1) {
        return false;
    }
    for (int i = 2; i <= sqrt(n); i++) {
        if (n % i == 0) {
            return false;
        }
    }
    return true;
}
int main(){
    int n;
    cin >> n;
    Node* root = NULL;
    unordered_map<int, Node*> m;
    for(int i=0; i<n; i++){
        int x, y, z;
        cin >> x >> y >> z;
        Node* curr;
        if(m.find(x) == m.end()){
            curr = new Node(x);
            m[x] = curr;
            if(root == NULL){
                root = curr;
            }
        }
        else{
            curr = m[x];
        }
        if(y != -1){
            Node* left;
            if(m.find(y) == m.end()){
                left = new Node(y);
                m[y] = left;
            }
            else{
                left = m[y];
            }
            curr->left = left;
            left->parent = curr;
        }
        if(z != -1){
            Node* right;
            if(m.find(z) == m.end()){
                right = new Node(z);
                m[z] = right;
            }
            else{
                right = m[z];
            }
            curr->right = right;
            right->parent = curr;
        }
    }
    
    vector<int> parent(n+1, -1);
    vector<int> in_order_traversal;
    inorder(parent, root->left, root, in_order_traversal);
    inorder(parent, root->right, root, in_order_traversal);
    
    
    int q;
    cin >> q;
    while(q--){
        int k;
        cin>>k;
        
        for(auto i : in_order_traversal){
            if(isPrime(i)){
                if(k == 1){
                    cout<<i<<' '<<parent.at(i)<<endl;
                    break;
                }
                else 
                    --k;
            }
        }
    }
    
    // performing the postorder traversal
    postorder(root);
    cout << endl;
    return 0;
}
